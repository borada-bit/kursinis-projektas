\documentclass{VUMIFInfKursinis}
\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{color}
\usepackage{graphicx}
% \usepackage{hyperref}  % Nuorodų aktyvavimas
\usepackage{url}
\usepackage{subcaption}	% package for subfigures
\usepackage{tabularx} % package for better figure width in document
\usepackage{pythonhighlight}


% Titulinio aprašas
\university{Vilniaus universitetas}
\faculty{Matematikos ir informatikos fakultetas}
\institute{Informatikos institutas}  % Užkomentavus šią eilutę - institutas neįtraukiamas į titulinį
\department{Informatikos katedra}
\papertype{Kursinis darbo projektas}
% Nenurodytas vienas arba keli iš būtinų atributų: kalba, raktiniai žodžiai, santrauka.
\title{Automatizuotas kriptovaliutų prekybos robotas}
\titleineng{Automated cryptocurrency trading bot}
\status{4 kurso 1 grupės studentas}
\author{Matas Kaminskas}
\supervisor{J. Asist., Dr. Igor Katin}
\date{Vilnius \\ \the\year}

% Nustatymai
% \setmainfont{Palemonas}   % Pakeisti teksto šriftą į Palemonas (turi būti įdiegtas sistemoje)
\bibliography{bibliografija} 

\begin{document}
\maketitle

\tableofcontents

% Įvade apibūdinamas darbo tikslas, temos aktualumas ir siekiami rezultatai. 
\sectionnonum{Įvadas}
% could be better, say something about novel nature of cryptocurrency
Pasaulis vis labiau modernėja, technologijos tampa vis išmanesnės ir našesnės, nei bet kada anksčiau. Šiais laikais turime kontraversiškai pagarsėjusią
kriptovaliutų rinką, kuri yra kaip skaidresnė atsvara standartinei akcijų biržai. Po 2007-2008 metų įvykusios finansų krizės,
visai neužilgo - \cite{nakamoto2008bitcoin} 2008 metais, atsirado pirmoji kriptovaliuta - Bitcoin. Tai yra decentralizuotą ir nepriklausoma elektroninę valiutą, paremta
blokų grandinės technologija. Dabartiniais apskaičiavimais šios rinkos bendra vertė viršija 800 milijardų JAV dolerių \cite{CoinMarketCap},
nors kiek daugiau nei prieš metus ši vertė buvo dvigubai didesnė - 1.6 trilijonų JAV dolerių, o tarp 2018 ir 2020 metų vertė daugmaž buvo stabili - apie 100 milijardų JAV dolerių.
Šie duomenys dar kartą pabrėžia kriptovaliutų rinkos nepastovumą, bei ženkliai padidėjusi susidomėjimą, populiarumą visuomenėje.    


Pagrindinis skirtumas tarp kriptovaliutų rinkos ir tradicines akcijų biržos yra jog mainai vyksta 24 valandas per parą. Akcijų biržoje yra nustatytos pagrindinės darbo valandos,
jos dažniausiai yra tokios pat kaip vietos darbo valandos ir pagrindiniai mainai vyksta šiomis valandomis, todėl stebėti tendencijas ir realizuoti strategijas yra įmanomas darbas asmeniui.
Kai rinka yra prieinama visa parą dirbant be sustojimo yra nepraktiška, bei neįmanoma stebėti ir atlikti prasmingus mainus rinkoje. Atsiranda puiki terpė automatizuoti šį 
procesą - įdarbinti automatizuotą prekybos robotą, kuris gebėtų analizuoti rinkos duomenis ir prognozuoti tolimesnė rinkos eigą.


Pratęsiant kursinio darbo temą, šio kursinio darbo projekto tikslas yra sukurti automatizuotą kriptovaliutų prekybos robotą. 
Darbe pritaikomas autoregresinių modelių veikimas, pagal kuriuos robotas galės remtis atliekant kriptovaliutų rinkos mainus. 

Tikslui įgyvendinti keliami uždaviniai:
\begin{itemize}
  \item mokslinės literatūros analizė,
  \item autoregresinių modelių pritaikymas,
  \item sukurti robotą gebanti remtis ištirtų modelių prognozėmis,
  \item paleisti robotą prekiauti testiniame tinkle,
  \item ištirti gautus rezultatus.
\end{itemize}


%Pagrindinėje tiriamojoje dalyje aptariama ir pagrindžiama tyrimo metodika;
%pagal atitinkamas darbo dalis, nuosekliai, panaudojant lyginamosios analizės,
%klasifikacijos, sisteminimo metodus bei apibendrinimus, dėstoma sukaupta ir išanalizuota medžiaga.
\section{Pagrindinė tiriamoji dalis}
% citation about impact of bitcoin on other coins? Explain mining (savoka)?
% koks tinklas?
Pagrindinė ir pirmoji kriptovaliuta - Bitcoin. Nors pirmieji 50 BTC buvo "iškasti" 2009 metų pradžioje, Bitcoin susilaukė didesnio dėmesio
tik 2013 metais\cite{macdonell2014popping}. Ši kriptovaliuta buvo laikoma ateities valiuta dėl savo naujoviškumo ir decentralizavimo, bet susilaukdavo ir 
neigiamų atsilipiemų dėl atsiskaitymo nelegaliuose prekybos vietuose internete. 
Vienas pirmųjų ir itin didelės apyvartos sulaukęs nelegalių prekių tinklalapis "Silkroad" atsiskaitymui už prekes naudojo Bitcoin.
Didelė apyvarta skatino bitcoin augimą, susidomėjimą ir kitų kriptovaliutų progresą.
% Source on correlation
Stebint kriptovaliutų rinką matoma koreliacija tarp Bitcoin kainos ir visų kitų kriptovaliutų kainos, taip dar kartą pabrėžiama, jog ši valiuta yra pagrindinė rinkoje.
Kyla bitcoin kaina - kyla kitų valiutų kaina, krenta bitcoin kaina - krenta kitų valiutų kaina. Retesniais atvejais kriptovaliutos sparčiau keičia kainą dėl 
pažangaus vystymosi ar dėl esančių problemų. 
% SOL auga labai? XRP freeze del teismo? ADA kyla nes pazangi, nors btc stabilus? ir kiti E.g. nezinu ar reikia čia šitą plėstis

% source on limited sources?
Dauguma kriptovaliutų yra riboto kiekio, tad jeigu prekybos robotas uždirba konkrečios kriptovaliutos mažai, jų kainą gali keleriopai išaugti 
tikrų valiutų atžvilgiu, todėl į kriptovaliutą galima žiūrėti ir kaip į investiciją. 2018 metais, nepaisant to, kad kriptovaliuta buvo galima 
atsiskaityti už paslaugas ar prekes, populiauriausia paskirtis buvo investicija. Viena iš priežaščių - tuo metu kaina buvo pakilus nenuspėjamai
aukštai\cite{garg2018autoregressive}. Akcijų birža, rinka naudojama investiciniais tikslais, jau kurį laiką yra analizuojama dėl savo finansinės
naudos ir sudėtingumo. Šios rinkos turi panašumų, todėl galima tirti akcijų biržos analizė literatūroje.

% Citation needed on cryptocurrency block chain, anonimty and everything else!
Šiais laikais vis daugiau žmonių naudojasi technologijomis ir nori nepriklausomybės nuo institucijų išleidžiamų ir manipuliuojami valiutų, infliacijos ir kitų dalykų, 
kurie mažina finansinių instituticijų pasitikėjimą. Kriptovaliutos yra paremtos blokų grandinės technologija, todėl daugelis jų yra decentralizuoti tinklai. 
Visa blokų informacija yra viešai prieinama publikai, puikiai žinoma tarp kokių šalių vyksta sandoriai, taip suteikiamas skaidresnis ir patikimesnis būdas publikai
turėti savo nepriklausomą rinką. Ypatingas kriptovaliutų bruožas yra tas, kad jų paprastai neišleidžia jokia centrinė institucija, todėl teoriškai jos nėra 
apsaugotos nuo vyriausybės kišimosi. Ankščiau minėtos savybės suteikia anonimiškumo, todėl tai sudaro palankias sąlygas klestėti sukčiavimo atvejams, 
"pump-and-dump" ar "ponzi" schemoms. Dažniausiai sutinkama yra "pump-and-dump" schema, kuri apibūdina procesą, kai valiutos paklausa yra iš anksto
apgalvotai ir trumpam padidinima, taip pakeliant jos kainą, vėliau, kai kainą yra pasiekusi tinkamą tašką, organizatoriai, staigiai parduoda savo
turimą kiekį, taip pasipelnydami\cite{xu2019anatomy}.

%social media influence?
Pagrindinis tyrimas šiame darbe yra tinkamiausio auto regresinio modelio parinkimas automatizuotam robotui lošėjui. Lošimo procesas tam tikrą laiką gali būti atliekamas žmogaus, 
stebėti besikeičiančias kainas ir atitinkamai elgtis, tačiau toks darbas yra monotoniškas ir atsiranda natūrali terpė jį automatizuoti. Automatizavimui
reikia taikyti pasirinktą strategiją, kuri spręstų kada yra tinkamas metas įsigyti kriptovaliutą, o kada parduoti, bet pirmiausia reikalingas tinkamas prognozavimo modelis.
Auto regresiniai modeliai taikomi laiko eilutėmis yra paplitę statistikoje norint prognozuoti tendenciją ateityje. Modelio prognozės tikslumui bei tinkamumui palyginti 
bus naudojama santykinė ir absoliuti klaidos.

\subsection{Darbinė aplinka}
Šiam robotui ir statistiniams modeliams teks naudotis jau sukurtais įrankiais, kurie palengvins darbą. Naudojama Python programavimo kalbą, 
kadangi ši kalba turi patogų API su dauguma kriptovaliutų rinkų ir patogias bibliotekas autoregresyviems modeliams bei kitiems reikalingiems API.

\subsubsection{Python}
Python yra aukšto lygio programavimo kalba. Joje galima sutikti ne viena programavimo paradigmą: procedurinę, objektinę ir netgi funkcinę.
Ši kalba suteikia patogu abstrakcijos lygį šiai užduočiai - automatizuoti robotą lošėją ir panaudoti AR modelius.
Šiais laikais python yra viena populiariausių kalbų pasaulyje, dėl savo paprastumo ir paprasto naudojomo naujam vartotojui, bet tikrai yra daugybę savybių
kuriomis prireiktų ne vienus metus suprasti ir prasmingai naudoti programuojant. Dėl šios kalbos privalumų dauguma egzistuojančių API
bibliotekų palaiko Python programavimo kalbą.


\subsubsubsection{Python-binance API}
Šiame darbe naudojama "python-binance" API. Šis API yra "Wrapper" oficialiam Binance API - binance-connector-python. 
Oficialus API yra labai paprastas ir lengvasvoris, todėl didelio patogumo nėra, tik paprasčiausios užklausos,
kurias visvien reikėtų apdoroti, todėl labai padeda padaryti šis "Wrapper" API.

\subsubsection{Binance}
Binance yra didžiausia kriptovaliutų birža pagal prekybos apimtį, turinti itin didelį valiutų pasiulą ir patogiai prieinamus duomenis. Ši birža taip pat
suteikia galimybė "lošti" kriptovaliutomis testiniame tinkle. Tinklo paskirtis yra lengvai nuspėjama iš pavadinimo, jame galima atlikti tuos pačius 
% issiplesti ir papasakoti apie rinkoje galimus atlikti veiksmus, LIMIT BUY, LIMIT SELL ir t.t.
veiksmus kaip realioje rinkoje, tik naudojama netikra valiuta kuri tikros vertės neturi.

% kas yra SPOT market parašyti? https://academy.binance.com/en/articles/a-complete-guide-to-cryptocurrency-trading-for-beginners
\subsubsubsection{Binance Spot Test Network}
Testinis tinklas yra beveik identiškas tikrajam "Binance" tinklui, kainos yra vienodos kaip ir pagrindiniame tinkle ar pasaulyje, todėl galima analizuoti 
seniausius rinkos duomenis ir juos taikyti reikiame modelyje. Testinis tinklas nėra toks populiarus, tad jame yra ženkliai mažiau prekiaujančių žmonių. 
Testiniame tinkle pąskyra sukuriama naudojant "Github" prisijungimą. Kiekvienas naujas vartotojas turi pradinį balansą susidendantį iš kriptovaliutų
matomų 1 lentelėje.

\begin{table}[H]\footnotesize
  % tablesgenerator.com - converts calculators (e.g. excel) tables to LaTeX
  \centering
  \caption{Pradinis likutis}
  {\begin{tabular}{|l|c|} \hline
      Kriptovaliuta & Kiekis  \\
      \hline
      BNB           & 1,000   \\
      BTC           & 1       \\
      BUSD          & 10,000  \\
      ETH           & 100     \\
      LTC           & 500     \\
      TRX           & 500,000 \\
      USDT          & 10,000  \\
      XRP           & 50,000  \\
      \hline 
    \end{tabular}}
\end{table}

Šiuo likučiu galima elgtis kaip norima. Pradinis likutis yra pakankamas atlikti prasmingoms transakcijomis testiniame tinkle. Reikėtų pabrėžti, jog testinis
tinklas kas mėnesį laiko yra iš naujo nustatomas ir visas turimas likutis yra konvertuojamas atgal į pradinį likutį, išvalant ankščiau buvusį balansą, tad jeigu
nepavyko praturtėti prekiaujant kriptovaliutomis, vėl įgaunama proga pradėti prekyba, na o sėkmingu atveju visas pelnas yra ištrinamas ir reikia vėl pradėti
nuo nulio.

% interpolation vs extrapolation?
\section{Laiko eilučių analizė}
"Visi modeliai yra klaidingi. Kai kurie modeliai yra naudingi" (angl. "All models are wrong. Some models are useful") - citata priskiriama George Box, kurios
reikėtų nepamiršti analizuojant laiko eilutes. Šis analizės būdas bando pastebėti pasikartojančius modelius bėgant laikui, jog būtų galima atlikti kuo tikslesnes
prognozes apie ateitį. 
Dažnu atveju tai yra vienas ar keli izoliuoti kintamieji, kurie yra stebimi nustatytą laiko tarpą ar surenkant jų istorinius duomenis. Laiko eilučių duomenų 
rinkimo ir analizavimo pavyzdžiai: sekamas paciento širdies pulsas, prekyboje sandelio prekių kieko priežiūra, konkrečios akcijos kainos prognozavimas akcijų biržoje. 
Laiko eilučių analizės vienas iš tikslų yra nuspėti kaip kinta reikšmė bėgant laikui, tai ir yra ko prireiks norint prognozuoti kriptovaliutų kainą šiam robotui. 
Kriptovaliutų kainų duomenys, taip pat yra laiko eilutė, nes kaina yra sekama bėgant laikui, tačiau dažniausiu atveju tai nėra stacionari laiko eilutė.
Reikia pabrėžti, kad toks analizės būdas tik bando nuspėti koks yra labiausiai tikėtinas rezultatas remiantis turimais duomeninimis ir naudojamu modeliu. 

\subsection {Laiko eilutės}
Laiko eilutė yra chronologiškai surikiuotas duomenų rinkinys. Laiko eilučiu analize analitkai gali pastebėti įvairias tendencijas ir taip prognozuoti reikšmes
ateityje bei geriau pasiruošti įvykiams. Laiko eilutė gali būti stacionari arba ne stacionari. Šiame darbe norint analizuoti turimus duomenis naudojant 
autoregresyvius modelius reikia turėti stacionarią laiko eilutę, jog būtų galima pritaikyti autoregresiniui modeliui. Tačiau kriptovaliutų kainą dažnu atveju yra
ne stacionari laiko eilutė, todėl prieš dirbant, reikia atitinkamai šiuos duomenis susitvarkyti arba analizuoti kitas eilutes.

\subsection {Laiko eilučių stacionarumas}
Stacionari laiko eilutė yra laikoma tokia eilutė, kurios statistinės savybės bėgant laikui nekinta \cite{nason2006stationary}. Tai reiškia, jog laiko eilutės vidurkis,
variacija ir kovariacija turi pastovias reikšmes. Stacionarios laiko eilutės yra lengviau analizuojamos, todėl autoregresyvieji modeliai yra pritaikyti dirbti su 
stacionariais duomenimis. Autoregresinių modelių taikymas nestacionariems duomenims gali suteikti nepatikimas prognozes ir prastesnius rezultatus. 
Prieš dirbant su duomenimis, juos galima pasiversti stacionariais, panaikinant sezoniškumus ar tendencijas imtyje.

\begin{figure}[H]
  \centering
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=.6\linewidth]{img/AMZN_daily_return.png}
    \caption{Stacionari laiko eilutė}
    \label{fig:sub1}
  \end{subfigure}%
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=.6\linewidth]{img/AMZN_daily_close.png}
    \caption{Nestacionari}
    \label{fig:sub2}
  \end{subfigure}
  \caption{Stacionari ir nestacionari laiko eilutė}
  \label{fig:test}
\end{figure}

Grafai parodantys skirtumą tarp stacionarios ir nestacionarios laiko eilutės. Grafuose naudojama "Amazon" kompanijos (NASDAQ: AMZN) akcijos duomenys gauti iš "Yahoo Finance" 
naudojant Python API\cite{yfinance}. Pirmajame (stacionariame) grafe yra pavaizduota kiekvienos dienos grąža investuojant į AMZN akciją trijų mėnesių laikotarpyje. 
Stacionarumas matomas ir vizualiai - vidurkis imtyje išlieka panašus, centruojasi ties 0, taip pat
% Variacija parodo kaip toli yra išsiskirste skaičiai imtyje, tai stacionariu atveju, nuo nulio atrodo visi panašų range turi. Variacija != standard deviation
% Kovariacija parodo kaip du kintamieji yra susije (teigiamai jei abu keičiasi vienodai arba negiamai jei keičaisi skirtinga kryptimi), čia svarbu kad ji išliktu vienoda (0 - nera rysio)
variacija ir kovariacija yra panašūs visuose taškuose. Antrame grafe yra pavaizduota tos pačios akcijos uždarymo kaina tokiame pat laikotarpyje. 
Nestacionarumas matomas ir vizualiai, kadangi yra akivaizdi tendencija žemyn. Šiuos teiginius patvirtina ir ADF testas. % Do I need to cite? 

% There are a few things you can try to improve the test:
% try using a different test for stationarity, such as the Kwiatkowski-Phillips-Schmidt-Shin (KPSS) test or the Phillips-Perron (PP) test.
% try differencing the data to remove any trend or seasonality. This can help to stabilize the variance of the data and make it more stationary.
% try applying a transformation to the data, such as taking the log of the data, to stabilize the variance and make the data more stationary.
% try using more data in the test. A larger sample size may provide more accurate results.
% try using a longer time period for the test. This can provide a more accurate assessment of stationarity, as it takes into account any long-term trends or seasonality in the data.
\subsection{ADF testas}
ADF (Angl. Augmented Dickey-Fuller) testas nustato ar laiko eilutė yra stacionari. Tai yra dažnai naudojamas įrankis analizuojant laiko eilutės ir jų algoritmais, kurie tikisi stacionarių 
duomenų\cite{chi2018stock}. Stacionariai laiko eilutėje privaloma atmesti nulinę hipotezę tam tikrame užtikrintumo intervale. 
Jeigu ADF testo absoliuti statistinė vertė yra daugiau už kritinę vertę, nulinę hipotezę yra atmetama ir ši laiko eilutė yra stacionari.
Pritaikius ADF testą{\cite{seabold2010statsmodels}} AMZN akcijų duomenims (\textbf{1 pav.}) gauti rezultatai:

% p reiksme, alfa reiksmingumo lygis
\begin{tabularx}{\linewidth}{|X|X|X|X|X|X|}
  \hline
  \textbf{Time Series} & \textbf{ADF Statistic} & \textbf{p-value} & \textbf{1\% Critical Value} & \textbf{5\% Critical Value} & \textbf{10\% Critical Value} \\ \hline
  Daily Returns        & -7.087                 & 0.000            & -3.542                      & -2.910                      & -2.593                       \\ \hline
  Daily Close Price    & -1.640                 & 0.461            & -3.542                      & -2.910                      & -2.593                       \\ \hline
\end{tabularx}

\vspace{10pt}
ADF statistika yra skaičius, kuris lyginamas su kritinėmis vertėmis skirtingais lygiais, kad būtų nuspręsta, ar atmesti ar priimti nulinę hipotezę apie stacionarumą. Pagal šiuos rezultatus
\begin{itemize}
  \item Pirmu atveju ADF statistika dienos grąžoms yra -7.087, kuri mažesnė, nei kritinė vertė -3.542 1\% lygyje. Nulinė hipotezė yra atmesta ir laiko eilutė laikoma stacionari.
  \item Antru atveju ADF statistika dienos uždarymo kainoms yra -1.640, kuri yra nemažesnė, nei kritinė vertė -3.542 1\% lygyje. Nulio hipotezė nėra atmesta ir laiko eilutė laikoma nestacionari.
\end{itemize}

\section{Autoregresiniai modeliai}
Vienas iš būdų analizuoti laiko eilutės yra autoregresija ir ją naudojantis modeliai. Egzistuoja ne vienas autoregresija naudojantis modelis. 
Populiarusi ir dažniausiai sutinkami modeliai yra ARMA(p, q) ir ARIMA(p, d, q).
Šie modeliai taip pat naudojasi anksčiau nepaminėtu MA modeliu kuris yra slankaus vidurkio modelis (angl. MA - moving average).
Taip pat yra SARIMA, SARFIMA ir kitų modelių, turinčių savo specifinius panaudjimo atvejus. 

\subsection{AR modelis}
AR (angl. autoregressive) modelis remiasi tik praeities duomenimis, kad nuspėti kintamojo reikšme ateityje. Ieškoma ar pastebimas pasikartojantis
modelis, kuris padėtų tiksliau atlikti prognozę ateityje\cite{chi2018stock}. Šis modelis dar dažnai vadinamas ARp modeliu, nes naudojamas kintamasis "p", nusakantis kiek praeiteis reikšmių 
iš laiko periodo norima naudoti. Laikant, kad kintamasis X yra laiko eilutės kintamasis AR(p) modelio formulė gali atrodyti taip: 
\[X_{t} = \Phi _{1}X_{t-1}+\epsilon_{t} \]

%\cite{chi2018stock} naudojami AR, MA ir ARMA modelio formulėms
${X_t}$ - stacionari laiko eilutė, $\Phi$ - AR modelio koeficientas, P - AR modelio laipsnis, $ \epsilon_{t} $ - AR modelio paklaida.

\subsection {MA modelis}
Toliau tyrinėjami autoregresyvieji modeliai susideda iš dar vienos dalies - Slankaus vidurkio - MA (angl. Moving average). Slenkančio vidurkio dabartinė
reikšmė tiesiškai priklauso nuo dabartines ir praeitų reikšmių. Žymėjimas MA(q) reiškia q laipsnio slenkamajį vidurkį, kurio formulę atrodo taip:  
\[X_{t} = \epsilon_{t} - \sum_{i=1}^{q}\theta_{i}  \epsilon_{t-i}\]

${X_t}$ - stacionari laiko eilutė, q - MA modelio laipsnis, ${\epsilon_t}$ - MA modelio paklaida.

\subsection {ARMA modelis}
ARMA (angl. autorogressive moving average) modelis yra autoregresyviaus ir slankaus vidurkio modelio junginys. Modelis dažnai žymimas
kaip ARMA(p, q), kur \textbf{p} yra AR laipsnis, o \textbf{q} yra MA laispnis. Pirmą kartą sujungtas 1938 mokslininko Herman Wold, jis pastebėjo jog ARMA modelis gal apimti 
dideles stacionarias laiko eilutes, kai yra tinkamai nurodytas p ir q laipsnis\cite{makridakis1997arma}. Taip pat reikia pabrėžti, 
jog ARMA(0, q) = MA(q) ir ARMA(p, 0) = AR(p). Reiškia, jog Xt eilutė gali būti modeliuojama kaip kombinacija praeities $x_{t}$ reikšmių ir/arba praeities $e_{t}$ klaidų:
\[X_{t} = \phi_{1}x_{t-1} + \phi_{2}x_{t-2} + ... + \phi_{p}x_{t-p} + e_{t} - \theta_{1}e_{t-1} - \theta_{2}e_{t-2} - ... - \theta_{q}e_{t-q}\]


\subsection {ARIMA modelis}
ARIMA (angl. autoregressive integrated moving average) modelis yra paplitęs nuo 1970-ųjų iki šių dienų. Modelio pavadinimo šifravimas
pažodžiui: AR - Autoregresinis modelis, I - Integracija (Diferencijavimas), atsižvelgiama į duomenų tendenciją, MA - (Moving average) Slankusis vidurkis.
AR ir MA yra atskiri modeliai, kurie gali būti naudojami paprastesnei laiko eilučiu analizei. Šio modelio privalumas, jog jis sujungia AR ir MA naudojimą kartu su
diferencijavimu, kuris suteikia galimybė giliau analizuoti laiko eilutes. Diferencijavimo dalis turimus duomenis padeda paversti į stacionarius, 
kurie yra reikalingi korektiškam modelio veikimui. Diferencijavimas vyksta baigtinį kartų skaičių, jog būtų pasiekta beveik-validi stacionari būseną. 
Kitais žodžiais ARIMA yra ekvivalentus ARMA modelis tiem patiems MA ir AR laipsniams \cite{hua2020bitcoin}. Taigi ARIMA modelis yra paremtas ARMA modeliu. 
Pagrindinis skirtumas tarp šių modelių yra tas, jog ARIMA konvertuoja nestacionarius duomenis į stacionarius prieš dirbant su jais. Modelio tipas yra 
klasifikuojamas kaip ARIMA(p,d,q), kur p - autoregresyvoji dalis, d - integravimo (diferencijavimo) dalis, q - slenkančio vidurkio dalis. Visos ARIMA modelio
reikšmės yra neneigiami sveikieji skaičiai \cite{mondal2014study}.

\subsection {SARIMA modelis}
SARIMA (angl. seasonal autoregressive integrated moving average) modelis yra ARIMA modelio išplėtimas turintis vieną papildomą savybę - sezoniškumą\cite{carl2020ethereum}. 
Pastebėjus, jog periodiškai kartojasi rezultatai laiko eilutėse, galima taikyti šį modelį. Geras ir paprastas pavyzdys, prekyba šventiniu laikotarpiu - kalėdos.
Prekybos centruose, tuo metu padidėja prekybą, tačiau kitą mėnesį ženkliai sumažėja. Spartus sumažėjimas nereiškia, jog prekybai yra didėlės problemos ir reikia pokyčių.
Tai dažniausiai yra žmonių poilsis nuo pirkinių po šventinio laikotarpio. šis modelis pastebi panašius sezoniškai atsitinkančius įvykius, juos atpažįsta ir pritaiko naudojant
ankščiau minėtą ARIMA modelį.

SARIMA galima išreikšti kaip ARIMA(p,d,q)(P,D,Q)[S], kur p,d,q standartiniai ARIMA modelio parametrai, o P - sezoniškumo autoregresivumo laipsnis,
D - sezoniškumo diferencijavimo laipsnis, Q - sezoniškumo slankiojo vidurkio laipsnis ir S - sezoniškumo ciklio ilgis. 

\section{Prognozių metodika}

Skyriuje aprašomi žingsniai, kurių buvo imtasi atliekant tyrimus ir analizę kuriant automatizuotą kriptovaliutų prekybos robotą. 
Tyrimo metu pagrindinis dėmesys buvo skiriamas tinkamų kriptovaliutų kainų analizės ir prognozavimo įrankiams ir metodams nustatyti bei skirtingų modelių veikimui įvertinti. 
Duomenys buvo renkami iš Binance testavimo tinklo naudojant python-binance API, o duomenims pritaikyti statistinės ir laiko eilučių analizės metodai. 
Kainų prognozavimui buvo naudojami autoregresyvūs modeliai, tokie kaip ARIMA ir SARIMA. 
Šio tyrimo išvados yra vienas iš pagrindų kuriant prekybos robotą.

\subsection{Modeliai}
Prognozavimui bus naudojami ARIMA ir SARIMA modelis. Kadangi kriptovaliutų kainų duomenys nėra stacionarūs, todėl naudojamas ARIMA modelis, kuris gali taikyti diferencijavimą.
ARIMA naudoja anksčiau minėtus AR ir MA modelius, bei pritaiko diferencijavimą, taip galėdamas dirbti ir su nestacionariais duomenimis. 
Jeigu laiko eilutė yra nestacionari ir bandoma naudoti AR, MA ir ARMA modelius, rezultatai galimai bus klaidingi arba netikslūs.
Taip pat naudojamas SARIMA modelis, nes jis yra ARIMA modelio pratęsimas tiriantis sezoniškumą laiko eilutėje, todėl dar bus patikrinama ar duomenyse egzistuoja sezoniškumas
galintis padėti prognozuoti.

% since network is test, used highest volatility pairs
\subsection{Duomenys}
Istoriniai duomenys "Candlesticks" surinkti iš Binance testavimo tinklo naudojant python-binance API. Kadangi testinis tinklas kiekvieną mėnesį automatiškai 
išvalo visus duomenis, imami 2023m. sausio 4d. duomenys savaitei į priekį, todėl verta paminėti, kad šie duomenys galioja tik tam tikrą laikotarpį. 
Kadangi tinklas yra testinis, jame prekiaujama nevisomis galimomis kriptovaliutų poromis. Iš viso yra 20 skirtingų porų tinkle. Pasirinkta tirti šias poras: 
i) BTC/BUSD, ii) LTC/BUSD, iii) XRP/BUSD.
Gaunamuose duomenyse yra daugiau informacijos bet bus naudojama tik datos ir `close' stulpelis, parodantis konkrečios kriptovaliutos uždarymo kainą tam tikru laiku. Tai yra paskutinė 
kaina, už kurią buvo prekiaujama tam tikru laikotarpiu, pavyzdžiui, valandą ar dieną. Uždarymo kaina yra svarbi, nes ji atspindi galutinę kainą, už kurią pirkėjai ir pardavėjai
sutarė prekiauti kriptovaliuta. Duomenys bus naudojami tokie kokie yra ir iškarto perduodami į modelius. Modeliui apmokyti naudojamas 90 procentų dumomenų rinkinio dydis.
Kitus 10\% bandoma prognozuoti po vieną reikšmę į priekį. Modeliui atlikus prognozė, jis yra iš naujo apmokomas pridėjus tikrąją sekančią vertę prie mokymo rinkinio ir
taip vėl yra prognozuojama kitą reikšmė, jau su naujai apmokytu modeliu.

% A detailed explanation of the model fitting process, including the specific parameters that you will be using for each of the AR models and any assumptions that you will be making.
\subsection{Modelių implementavimas}
Prognozuojant naudojamos ARIMA ir SARIMA pagalbinės bibliotekos\cite{seabold2010statsmodels} kuri aprašo šiuos modelius, 
bei euristins auto\_arima algoritmas\cite{pmdarima} padedantis nustatyti geriausius ARIMA ir SARIMA parametrus konkrečiam duomenų rinkiniui.
SARIMA modeliui sezoniškumo intervalas naudojamas 4 - bandoma pamatyti ar atsiranda sezoniškumas kiekvieną valandą, nes duomenų intervalas yra 15min.
Modelių vertinimui bus naudojama MSE ir MAPE paklaidos.

\subsection{Prognozavimas}

Kriptovaliutų kainų prognozavimo metodas naudoja anksčiau minėtus modelius ir Binance testinio tinklo duomenis. 
Žemiau matoma struktūrinę schemą, parodanti bendrą procesą, kurį sudaro keli pagrindiniai žingsniai. 
Pirmas žingsnis yra duomenų gavimas is binance API, bet jų gaunama daugiau negu reikia, todėl atsirenkami tik reikalingi duomenys, šis žingsnis yra
svarbus norint įsitikinti,kad duomenys yra paruošti analizei. Po to pasirenkame modelį (ARIMA/SARIMA).
Kitame žingsnyje yra gaunami geriausi parametrai konkrečiam duomenų rinkiniui ir modeliui, kad būtų optimalus veikimas. 
Tada taikome modelį treniruočių duomenims, kad apmokyti modelį tolimesniam prognozavimui. 
Po to modelis prognozuoja reikšmes ir jos yra saugomos, kad būtų galima palyginti su tikromis reikšmemis. Paskutinis žingsnis - palyginti gautus rezultatus
ir išsaugoti duomenis grafe. Pateikta struktūrinė schema padės geriau suprasti visą procesą.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{img/flowchart.png}
  \label{fig:forecast_flowchart}
  \caption{Struktūrinė schema}
\end{figure}

\subsection{Vertinimas}

Vidutinė kvadratinė paklaida (MSE) ir vidutinė absoliučioji procentinė paklaida (MAPE) yra dvi dažniausios metrikos, naudojamos prognozavimo modelių našumui įvertinti.
MSE yra prognozuotų ir faktinių verčių vidutinio skirtumo kvadrato matas, o MAPE yra vidutinio procentinio skirtumo tarp numatytų ir faktinių verčių matas.
Abu šie rodikliai gali būti naudingi lyginant ARIMA ir SARIMA prognozavimo kriptovaliutoms rezultatus.
MSE yra gera metrika norint išmatuoti, kiek prognozės nukrypsta nuo faktinių verčių, mažesnė MSE reikšmė rodo tikslesnį modelį. 
MAPE yra gera metrika prognozavimo paklaidoms procentais matuoti, mažesnė MAPE reikšmė rodo tikslesnį modelį.
Abi šios metrikos gali būti naudojamos vertinant modelių veikimą ir lyginant ARIMA ir SARIMA prognozavimo kriptovaliutoms rezultatus.

% An evaluation of the performance of your models against the actual crypto prices, and a discussion of how well your models were able to predict future prices.
% A schematic or flowchart that visually illustrates the steps of your methodology, which will help your readers understand the process you used.
% A discussion of any evaluation metrics you will be using to assess the performance of your models, such as mean squared error or Akaike information criterion.

\section{Prognozių realizacija}
Šio darbo realizavimo ir rezultatų skyriuje pristatomas metodikos įgyvendinimas ir gauti rezultatai. 
Skyriuje pateikiamos duomenų ir prognozavimo rezultatų vizualizacijos, taip pat kodo fragmentai, demonstruojantys naudojamų modelių įgyvendinimą.
Vizualizacijos suteikia aiškų vaizdą apie modelių veikimą ir prognozių tikslumą. 
Kodo fragmentai suteikia išsamų supratimą apie modelių įgyvendinimą. 
Šioje dalyje taip pat palyginami rezultatai, gauti naudojant ARIMA ir SARIMA modelius, leidžiantys įvertinti modelių veikimą.
\subsection{Modelių realizacija}

Iš pradžių prisijungiama prie testinio tinklo naudojant API ir naudotojo raktus

\begin{python}
  with open(CONFIG_FILE_NAME, 'r') as config_file:
  	data = json.load(config_file)
  	validate(instance=data, schema=config_schema)
  	client = Client(data['api_key'], data['api_secret'], testnet=True)
\end{python}

Tuomet gaunami istoriniai duomenys iš API. Kaip minėta, jog Sausio 4d. įvykio atnaujinimas ir eksperimentiniais tikslais imama duomenys savaitė nuo pradžios į priekį.
tuomet kviečiami funkcija, jog paverstų gautus duomenis į reikalinga struktūrą.

\begin{python}
  klines = client.get_historical_klines(symbol, Client.KLINE_INTERVAL_15MINUTE, end_str='11 Jan, 2023')
  df = binance_klines_to_df(klines)
  model_predict_arima(symbol, df)
  model_predict_arima(symbol, df, seasonal=True)

  def binance_klines_to_df(klines):
  	klines = np.array(klines)
  	df = pd.DataFrame(klines.reshape(-1, 12), dtype=float, columns=KLINES_COLUMNS)
  	df['Open Time'] = pd.to_datetime(df['Open Time'], unit='ms')
  	return df
\end{python}

Turint duomenis kviečiama model\_predict\_arima funckija, kuri pagal seasonal parametrą atlieka ARIMA arba SARIMA modelį.

\begin{python}
  df = df[['Open Time', 'Close']]
  df.set_index('Open Time', inplace=True)
  
  to_row = int(len(df) * 0.9)
  training_data = list(df[0:to_row]['Close'])
  
  if seasonal:
  	order, seasonal_order = best_params_arima_seasonal(training_data)
  else:
  	order = best_params_arima(training_data)
  	seasonal_order = None
  
  testing_data = list(df[to_row:]['Close'])
  model_predictions = []
  for i in range(len(testing_data)):
  	model = ARIMA(training_data, order=order, seasonal_order=seasonal_order)
  	model_fit = model.fit()
  	output = model_fit.forecast(steps=1)
  	yhat = output[0]
  	model_predictions.append(yhat)
  	actual_test_value = testing_data[i]
  	training_data.append(actual_test_value)
\end{python}

Pagrindinė kodo dalis atliekanti skaičiavimus
Pasiemama is duomenų tik data ir uždarymo kainą, tuomet duomenys padalijami 90\% apmokymui ir kita dalis prognozavimui. Tuomet modeliui gaunami 
optimalūs parametrai. Po šito inicijuojamas tuščias sąrašas, vadinamas model\_predictions. Kiekvienai iteracijai atliekami šie veiksmus:

\begin{itemize}
  \item sukuria ARIMA modelį turimais duomenimis ir parametrais ir jis yra pritaikomas naudojant fit().
  \item gaunama prognozuojama reikšmė yhat
  \item prie prognozių sąrašo pridedama reikšmė
  \item į turimus duomenis pridedama tikroji reikšmė ir toliau cikliškai apmokamas modelis
\end{itemize}

\subsection{Prognozės}

Šie rezultatai rodo ARIMA ir SARIMA modelių našumą prognozuojant trijų skirtingų simbolių - BTCBUSD, LTCBUSD ir XRPBUSD - kriptovaliutų kainas.
Modelių veikimui įvertinti naudojami MSE (Mean Squared Error) ir MAPE (Mean Absolute Percentage Error). 
MSE matuoja vidutinį skirtumą tarp numatytų ir faktinių verčių kvadratu, o MAPE - vidutinį procentinį skirtumą tarp numatomų ir faktinių verčių. 
Abu šie rodikliai yra svarbūs vertinant modelių tikslumą.

Taikymo rezultatai trims skirtingoms kriptovaliutų poroms: BTCBUSD, LTCBUSD ir XRPBUSD. Grafikuose matosi prognozuota ir tikra kaina laikotarpiu.
BTCBUSD
\begin{figure}[H]
  \centering
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{img/BTCBUSD__ARIMA(1, 1, 1).png}
    \caption{ARIMA modelis}
    \label{fig:btcbusd_arima}
  \end{subfigure}%
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{img/BTCBUSD_seasonal_ARIMA(1, 1, 1)(0, 1, 1, 4).png}
    \caption{SARIMA modelis}
    \label{fig:btcbusd_sarima}
  \end{subfigure}
  \caption{BTCUSD prognozavimas}
  \label{fig:btcbusd}
\end{figure}

LTCBUSD
\begin{figure}[H]
  \centering
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{img/LTCBUSD__ARIMA(2, 1, 2).png}
    \caption{ARIMA modelis}
    \label{fig:ltcbusd_arima}
  \end{subfigure}%
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{img/LTCBUSD_seasonal_ARIMA(0, 1, 0)(2, 1, 0, 4).png}
    \caption{SARIMA modelis}
    \label{fig:ltcbusd_sarima}
  \end{subfigure}
  \caption{LTCBUSD prognozavimas}
  \label{fig:ltcbusd}
\end{figure}

XRPBUSD
\begin{figure}[H]
  \centering
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{img/XRPBUSD__ARIMA(0, 1, 2).png}
    \caption{ARIMA modelis}
    \label{fig:xrpbusd_arima}
  \end{subfigure}%
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{img/XRPBUSD_seasonal_ARIMA(2, 1, 3)(0, 1, 2, 4).png}
    \caption{SARIMA modelis}
    \label{fig:xrpbusd_sarima}
  \end{subfigure}
  \caption{XRPBUSD prognozavimas}
  \label{fig:xrpbusd}
\end{figure}

\vspace{20pt}

\begin{table}[H]
  \centering
  \begin{tabularx}{\linewidth}{|X|X|X|X|}
    \hline
    Symbol  & Model  & MSE      & MAPE   \\
    \hline
    \hline
    BTCBUSD & ARIMA  & 13702.25 & 0.22\% \\
    \hline
    BTCBUSD & SARIMA & 13349.98 & 0.24\% \\
    \hline
    \hline
    LTCBUSD & ARIMA  & 0.05     & 0.2\%  \\
    \hline
    LTCBUSD & SARIMA & 0.06     & 0.24\% \\
    \hline
    \hline
    XRPBUSD & ARIMA  & 4.92     & 0.16\% \\
    \hline
    XRPBUSD & SARIMA & 5.24     & 0.17\% \\
    \hline
  \end{tabularx}
  \caption{Modelių taikymo rezultatai}
  \label{table:rezultatai}
\end{table}

Iš lentelės matome, kad BTCBUSD poros MSE yra šiek tiek mažesnė SARIMA modeliui nei ARIMA modeliui, tai rodo, kad SARIMA modelis gali šiek tiek geriau atitikti šį duomenų rinkinį, bet MAPE yra šiek tiek mažesnė ARIMA modeliui.

LTCBUSD ir XRPBUSD poroje abiejų modelių MSE ir MAPE yra panašiai žemi, o tai rodo, kad abiejų modelių šių duomenų rinkinių našumas yra panašus. Visų porų MSE ir MAPE yra palyginti žemos, o tai rodo, kad modeliai gerai tinka duomenims, o prognozės yra gana tikslios.

Verta paminėti, kad šie rezultatai yra naudojami konkrečiams duomenų rinkiniui, taigi modeliai gali duoti skirtingus rezultatus kitiems rinkiniams.

\section{Prekybos robotas}
Skyriuje siekiama nuodugniai pažvelgti į automatizuoto roboto metodiką bei roboto kūrimo ir taikytų strategijų rezultatus.
Pagrindinis dėmesys bus skiriamas paaiškinimui, kaip kuriamas robotas, kaip atliekami sandoriai ir kokie rezultatai gaunami naudojant skirtingas strategijas.

\subsection{Metodika}
Robotas parašytas "Python" programavimo kalbą naudojant "python-binance" API bendrauti su Binance testiniu tinklu\cite{trading_robot}. 
Yra keli pagrindiniai žingsniai roboto veikime.

\begin{enumerate}
  \item Įkeliama konfigūracija ir simbolių duomenys iš failų, duomenys patikrinami pagal validacijos schemas, inicijuojami API prieigos ir klasės kintamieji.
  \item Gaunami istoriniai simbolių "klines" duomenys, kurie yra saugojami naudojimui.
  \item Siūlomas vartotojui sąveikos su prekybos robotu parinkčių meniu, pvz., likučių, pavedimų, pozicijų, simbolių informacijos spausdinimas ir pavedimų atšaukimas.
  \item [4a.] Vykdomas meniu pasirinkimas
  \item [4b.] Skaičiuojamos taikomos strategijos prognozės ir robotas bando atlikti sandorius, jei sąlygos ir tenkinamos.
  \item [4c.] Išsaugo kriptovaliutų porų pozicijas, kai vartotojas išeina iš programos.
\end{enumerate}

Pagrindinės būsena yra 3, kai robotas laukia įvesties iš vartotojo arba laukia kol pasibaigs nustatytas prekiavimo laikas, tuomet pereis į vieną iš 4 būsenų, arba bus vykdoma, 
meniu pasirinkimas, pvz. spausdinti dabartinį balansą arba bus bandoma atlikti prekybą arba tiesiog baigti darbą. Toliau apie visą eigą plačiau poskyriuose.

\begin{figure}[H]
  \centering
  \includegraphics[width=.5\textwidth]{img/main_states.png}
  \label{fig:main_states}
  \caption{Pagrindinės būsenos}
\end{figure}

\subsubsection{Validacija}
Darbo pradžia - vykdoma validacija, kuri patikrina ar konfigūracija yra teisinga ir galima toliau prekiauti robotui - t.y.
porų duomenis yra tvarkingi, pasirinkta egzistuojanti strategija ir pateikti jai reikalingi kintamieji, pasirinktas prekiavimo intervalas bei kiti kintamieji.

\begin{figure}[H]
  \centering
  \includegraphics[width=.5\textwidth]{img/validacija.png}
  \label{fig:validation_flowchat}
  \caption{Validacijos struktūrinė schema}
\end{figure}


\subsubsection{Meniu}
Robotui sėkmingai įvykdžius validaciją sutinkamas meniu, kuriame galima atlikti vartotojui reikalingas operacijas, tokias kaip pasižiūrėti valiutų balansą,
pažiūrėti įvykdytus sandorius ar tiesiog baigti darbą.

Galimi pasirinkimai pradėjus roboto darbą.
\begin{enumerate}
  \item Spausdinti paskyros balansą.
  \item Spausdinti simbolių poros sandorius.
  \item Spausdinti dabartines kriptovaliutų porų pozicijas.
  \item Spausdinti sandorį pagal ID.
  \item Atšaukti sandorį rankiniu būdu.
  \item Išsaugoti simbolio sandorių grafiką.
  \item[9.] Spausdinti meniu.
  \item[0.] Baigti darbą.
  \item[-1.] Bandyti atlikti sandorius (Numatyta meniu parinktis pasibaigus laukimo laikui).
\end{enumerate}

Robotui prireikia minimalios vartotojo sąsajos, kad būtų galima sekti progresą ir atliktus darbus.
Galima pasižiūrėti paskyros balansą ar atšaukti rankiniu būdu sandorį. Šios komandos praverčia atliekant sandorius, kurie gali būti atliekami ne iš karto. Taip pat patogu
gauti duomenys iš API, kad sužinoti kokie sandoriai kokiu laiku būdu buvo vykdomi, taip nereikia saugoti žurnale šios informacijos. Vienintelis minusas, jog nebus aišku,
kokia strategija buvo taikyta, kadangi tai yra šios programos implementacijos reikalas. Šis meniu yra visada matomas vartotojo. 
Jeigu nepasirinkta jokia operacija, po nustayto laiko, robotas automatiškai pasirenka paskutinį variantą ir bando atlikti sandorius.

\begin{figure}[H]
  \centering
  \includegraphics[width=.5\textwidth]{img/meniu.png}
  \label{fig:meniu_flowchart}
  \caption{Meniu schema}
\end{figure}

\subsubsection{Prekyba}
Robotui sėkmingai pradėjus darbą ir praėjus laiko tarpui po kurio robotas pradeda bandyti prekiauti, bandoma atlikti pagrindinį žingsnį - prekybą.
Pagrindiniai žingsniai yra tokie:
\begin{itemize}
  \item Skaičiuojama ARIMA prognozė arba skaičiuojamos trumpojo ir ilgojo vidurkio vertes, pagal pasirinktą strategiją.
  \item Tikrinamos sąlygos pagal apskaičiuotas vertes.
  \item Jeigu sąlygos tinkamos bandoma atlikti sandorį, kitu atveju grįžtama į meniu ir vėl laukiama kada reikės bandyti atlikti sandorį su naujesniais duomenimis.
  \item Jeigu reikia atlikti sandorį, jį bandoma atlikti. Bet sandoris nevisada gali pavykti, ypač jei norima pirkti nustatytą kainą, sandoris gali būti neįvykdomas, todėl dar bandoma jį kartoti.
  \item Jei sandoris pavyko, grįžtama į meniu būseną kur vėl robotas yra laukimo būsenoje.
\end{itemize}

Taigi procesas gana paprastas - atnaujinami duomenis ir bandomas atlikti sandoris, jei sąlygos yra tenkinamos. Taip pat jeigu sandoris nepavyksta, sandorį
dar bandoma po nustatyto laukimo laiko pakartoti kelis kartus pagal nustatymus. Tai praverčia jeigu norima prekiauti nustatytą kainą, o ne tokia kokią Siūlo 
rinka, bet kitais atvejais sandoris taip ir gali nepavykti, nes niekas nepriima tokios kainos ir sandoris bus neįvykdytas pagal turimas prognozes.

\begin{figure}[H]
  \centering
  \includegraphics[width=.5\textwidth]{img/prekyba.png}
  \label{fig:trade_flowchart}
  \caption{Prekybos struktūrinė schema}
\end{figure}


\subsection{Strategijos}
\subsubsection{Tendencijos sekimas}

Šiuo atveju vykdoma strategija yra standartinė pirkimo ir laikymo strategija. Robotas naudoja ARIMA, kad sudarytų pasirinktų kriptovaliutų porų kainos prognozes. 
Kai prognozė numato kylančią kainą, robotas įvykdys pirkimo pavedimą, o prognozei numatant mažėjančią kainą robotas vykdys pardavimo pavedimą. 
Šio tipo strategija paremta idėja, kad galima pasipelnyti iš rinkos tendencijų perkant pigiai ir parduodant brangiai.
Robotas naudoja ARIMA, kad analizuotų istorinius kainų duomenis ir prognozuotų būsimus kainų pokyčius, kuriuos jis naudoja priimdamas pirkimo ir pardavimo sprendimus.
Vadovaudamasis šia strategija, robotas siekia pasinaudoti rinkos tendencijomis. 

\begin {itemize}
\item ARIMA prognozuoja kriptovaliutos kainą.
\item Remiantis prognoze, jei modelis numato didėjimo tendenciją, bandoma nusipirkti kriptovaliutą, o jei prognozuoja mažėjimo tendenciją, bandoma kriptovaliutą parduoti.
\item Nuolat stebima kriptovaliutos kainą ir atitinkamai atnaujinamas ARIMA modelis, kad būtų atnaujintos prognozes.
\end{itemize}

\subsubsection{Grįžimas prie vidurkio}

Grįžimas prie vidurkio yra prekybos strategija, pagrįsta idėja, kad kainos laikui bėgant grįžta į savo vidurkį. 
Tai apima dabartinės kainos palyginimą su istorine vidutine kaina. Sandoris yra sudaromas pagal tai, ar dabartinė kaina yra didesnė ar mažesnė už vidutinę.
Pagal šią strategiją, jei dabartinė kaina yra didesnė už istorinį vidurkį, prekiautojas parduotų turtą, o jei ji yra mažesnė, prekiautojas pirktų. 
Tikslas - pasinaudoti rinkos tendencija grįžti prie vidurkio.

\begin {itemize}
\item Apskaičiuojama kriptovaliutos pastarųjų trumpojo ir ilgojo intervalų paprastą slenkantį vidurkį (SMA).
\item Jei trumpasis SMA yra didesnis nei ilgasis SMA - bandoma parduoti kriptovaliutą.
\item Jei trumpasis SMA yra mažesnis nei ilgasis SMA - bandoma pirkti kriptovaliutą.
\item Nuolat stebima kriptovaliutos kaina ir atitinkamai atnaujinami SMA.
\end {itemize}

Strategija grindžiama idėja, kad kai kriptovaliutos kaina nukrypsta nuo vidutinės vertės, ji ilgainiui grįš į vidutinę. Šiuo atveju vidurkį atstoja kainos paprastasis slankusis vidurkis (SMA),
o nuokrypis nuo vidurkio nustatomas lyginant trumpalaikį SMA ir ilgalaikį SMA. Jei trumpalaikis SMA yra didesnis nei ilgalaikis SMA, tada daroma prielaida, kad kaina nukrypsta nuo vidurkio
ir galiausiai grįš, todėl bandoma atlikti pardavimą. Ir atvirkščiai, jei trumpalaikis SMA yra mažesnis už ilgalaikį SMA, tada pateikiamas pirkimo pavedimas, numatant, kad kaina grįš į vidutinę.
Šioje programoje, galima pasirinkti kiek pastarųjų verčių kainų vidurkį skaičiuoti trumpajam ir ilgajam SMA.


\subsection{Realizacija}

Toliau robotui sandoriams atlikti pasirinktos šios kriptovaliutų poros. 
\begin {itemize}
\item BTC/BUSD
\item ETH/BUSD
\item LTC/BUSD
\end {itemize}
Šios poros yra populiarios ir dažnai prekiaujamos tinkle, todėl jomis bus paprasčiau naudotis. Kadangi tinklas yra testinis, didžiausios prekybos apimties sulaukia
tik populiariausios kriptovaliutos.

\subsubsection{Konfigūracija}
Naudojamų porų konfigūracija prekiauti kriptovaliutų poromis. Pasirenkama kiekis po kiek prekiauti, pirkimo ar pardavimo pozicija, koks yra užsakymo
tipas ("LIMIT" arba "MARKET" ) ir jeigu tipas yra "LIMIT" pasirinkti užsakymo reikšmę: "FOK", "IOC" arba "GTC". Žemiau pateikta konfigūracija naudojama 
prekiauti abiejomis strategijomis.

\begin{verbatim}
  {
  "BTCBUSD": {
    "trade_quantity": 0.01, # Kiekis kuriuo prekiaujama
    "position": "BUY", # Dabartinė pozicija
    "order_type": "LIMIT", # Užsakymo tipas (LIMIT arba MARKET)
    "time_in_force": "FOK" # LIMIT nustatymas (FOK, GTC arba IOC)
  },
  "ETHBUSD": {
    "trade_quantity": 0.1,
    "position": "BUY",
    "order_type": "LIMIT",
    "time_in_force": "FOK"
  },
  "LTCBUSD": {
    "trade_quantity": 1,
    "position": "BUY",
    "order_type": "LIMIT",
    "time_in_force": "FOK"
  }
\end{verbatim}

Taip pat yra dar vienas konfigūracijos failas kuriame įrašoma API prieigos raktai, strategija, prekybos laikas ir kokio intervalo duomenis naudoti. Žemiau pateika 
strategija buvo naudojama prekiauti "Grįžimo prie vidurkio" strategijai. "Tendencijos sekimo" strategijai viskas tas pats, tik nebelieka "long\_term" ir "short\_term"
kintamųjų ir strategija pakeičiama į "TENDENCY\_ARIMA" 

\begin{verbatim}
{
  "api_key": "key", # API prieigos raktas
  "api_secret": "s3cr3t", # API prieigos slaptas raktas
  "timeout": 900, # Kas kiek laiko bandyti prekiauti
  "interval": "15m", # Kokio intervalo duomenis naudoti
  "strategy": "MEAN_SMA", # Strategija (MEAN_SMA arba TENDENCY_ARIMA)
  "long_term": 15, # MEAN_SMA strategijos ilgojo slankaus vidurkio parametras
  "short_term": 5 # MEAN_SMA strategijos trumpojo slankaus vidurkio parametras
}
\end{verbatim}

\subsubsection{Prekybos realizacija}
Robotas skirtas analizuoti rinkos tendencijas ir priimti pagrįstus sprendimus, kada pirkti ir parduoti kriptovaliutas. 
Kad tai pasiektų, robotas naudoja ARIMA analizę ir paprastą slenkantį vidurkį (SMA).
Šios technikos leidžia robotui nuolat stebėti rinkos sąlygas ir sudaryti sandorius remiantis realaus laiko duomenimis. 
Ištirsime, kaip robotas integruoja šias strategijas ir procesą, kuriuo jis pateikia pavedimus ir vykdo sandorius.

Programos pradžioje, praėjus validacijai ir inicializacijai, kodas patikrina, kokia prekybos strategija pasirinkta ir pagal tai atlieka reikiamus skaičiavimus. Jei pasirenkama MEAN\_STRATEGY, nuskaitoma istorines kriptovaliutos kainas (tiek pastarųjų verčių koks ilgojo slankaus vidurkio parametras) ir apskaičiuoja trumpąjį ir ilgąjį paprastąjį slankųjį vidurkį (SMA). Jei pasirinkta TENDNCY\_ARIMA, ji nuskaito pastarųjų 1000 intervalo "candlesticks" eilučių duomenis ir apskaičiuoja ARIMA prognozę.
\begin{python}
  if self._strategy == MEAN_STRATEGY:
  self._get_historic_prices(limit=self._long_term)
  self._calculate_sma()
  elif self._strategy == TENDENCY_STRATEGY:
  self._get_klines_as_df(limit=1000)
  self._calculate_arima()
\end{python}

Toliau, kai praeina nustatytas "timeout" laikas, programa kviečia \_try\_trade funkciją , kuri vykdo atitinkamą prekybos strategiją priklausomai nuo strategijos. Abi strategijos atnaujina savo duomenis, išmesdama seniausia verte ir pridedama
naujausia kainos vertę, tuomet pagal strategija atliekami SMA arba ARIMA skaičiavimai ir bandoma atitinkamai atlikti 
užsakymą.

\begin{python}
  def _try_trade(self) -> None:
  klines = 1
  if self._strategy == MEAN_STRATEGY:
  self._get_historic_prices(klines)
  self._calculate_sma()
  self._trade_sma()
  elif self._strategy == TENDENCY_STRATEGY:
  self._get_klines_as_df(klines)
  self._calculate_arima()
  self._trade_arima()
\end{python}

Šis kodo blokas gauna vidutinę konkretaus simbolio kainą rinkoje jeigu yra nustatytas "LIMIT" užsakymo tipas ir atlieka sandorius pagal strategiją. Patikrinama, ar trumpalaikis SMA didesnis už ilgalaikį SMA ir ar esama pozicija yra pirki, o jei tenkinamos abi sąlygos, pateikia užsakymą parduoti nurodytą simbolio kiekį už apskaičiuotą vidutinę kainą. Jei trumpalaikis SMA yra mažesnis už ilgalaikį SMA, o dabartinė pozicija yra parduoti, pateikiamas užsakymas pirkti nurodytą simbolio kiekį. Atlikus sandorį, padėtis atnaujinama, kad atspindėtų naują būseną. Analogiškai vyksta ir tendencijos strategijoje - tikrinama ar ARIMA prognozuojama kainą yra didesnę ar mažesnę už dabartinę vidutinę kainą ir atitinkamai atliekamas užsakymas.

\begin{python}
  price = None
  if config['order_type'] == Client.ORDER_TYPE_LIMIT:
  price = self._get_symbol_avg_price(symbol)
  if short_sma > long_sma and position == 'BUY':
  if self._make_order(symbol, position, config['trade_quantity'], price):
  config['position'] = 'SELL'
  elif short_sma < long_sma and position == 'SELL':
  if self._make_order(symbol, position, config['trade_quantity'], price):
  config['position'] = 'BUY'
\end{python}

Funkcija \_make\_order naudojama norint atlikti konkretaus simbolio užsakymą su nurodyta puse (pirkti arba parduoti), kiekiu ir kaina. Naudojama „create\_order“ metodą iš „Binance“ API ir nustato simbolio parametrus remiantis konfigūracija.

Funkcija turi pakartotinio bandymo mechanizmą, kad kelis kartus būtų bandoma pateikti užsakymą, jei atsiranda klaidų arba užsakymas būtų atmestas. Pakartotinių bandymų kintamasis nustatomas į 0 ir didėja 1 po kiekvieno nesėkmingo bandymo. Jei pakartojimų skaičius viršija ORDER\_MAX\_RETRIES (prekybos atveju šis kintamasis yra - 3), funkcija grąžins False, nurodydama, kad užsakymas nebuvo baigtas.

Po kiekvieno bandymo funkcija laukia tam tikrą laiką, apibrėžtą ORDER\_RETRY\_WAIT\_TIME (prekybos atveju šis kintamasis yra - 10), prieš bandydama dar kartą. Jei užsakymas bus užpildytas, atsakymo būsena bus „FILLED“, o funkcija grąžins True, nurodydama, kad užsakymas įvykdytas sėkmingai.

\begin{python}
  def _make_order(self, symbol: str, side: str, qty: float, price: float = None) -> bool:
  # Retry is useful if order type is LIMIT
  retries = 0
  order_completed = False
  while not order_completed and retries < ORDER_MAX_RETRIES:
  try:
  response = self._client.create_order(
  symbol=symbol,
  side=side,
  type=self._pairs_config[symbol]['order_type'],
  quantity=qty,
  price=price,
  timeInForce=self._pairs_config[symbol]['time_in_force'],
  )
  print(f"{response['side']} {response['type']} {response['symbol']} {response['status']}")
  if response['status'] == Client.ORDER_STATUS_FILLED:
  order_completed = True
  break
  except exceptions.BinanceOrderException as e:
  print(e.message)
  retries += 1
  time.sleep(ORDER_RETRY_WAIT_TIME)
  return order_completed
\end{python}


\subsubsection{Prekybos rezultatai}
Prekybos rezultatų poskyris yra automatizuoto kriptovaliutų prekybos roboto veikimo įvertinimas. Šioje skiltyje bus vaizdžiai pavaizduoti prekybos strategijos, įgyvendintos naudojant grafikus ir diagramas, rezultatai. Roboto krepšelio pokytis bus lyginamas su pradiniu krepšeliu prieš pradedant prekybą. Šios dalies tikslas – įvertinti bendrą roboto pelningumą ir pateikti jo prekybos rezultatų analizę.

Prekyba buvo atlikta naudojant abi aprašytas strategijas, ir palikus robotą dirbti nakties metu, bandant atlikti prekyba kas
15 minučių.


\begin{figure}[H]
  \centering
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{img/BTCBUSD_ARIMA_trades.png}
    \caption{Tendencijos sekimas}
    \label{fig:btcbusd_arima_trades}
  \end{subfigure}%
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{img/BTCBUSD_SMA_trades.png}
    \caption{Grįžimas prie vidurkio}
    \label{fig:btcbusd_sma_trades}
  \end{subfigure}
  \caption{BTCBUSD prekyba}
  \label{fig:btcbusd_trades}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{img/ETHBUSD_ARIMA_trades.png}
    \caption{Tendencijos sekimas}
    \label{fig:ethbusd_arima_trades}
  \end{subfigure}%
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{img/ETHBUSD_SMA_trades.png}
    \caption{Grįžimas prie vidurkio}
    \label{fig:ethbusd_sma_trades}
  \end{subfigure}
  \caption{ETHBUSD prekyba}
  \label{fig:ethbusd_trades}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{img/LTCBUSD_ARIMA_trades.png}
    \caption{Tendencijos sekimas}
    \label{fig:ltcbusd_arima_trades}
  \end{subfigure}%
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{img/LTCBUSD_SMA_trades.png}
    \caption{SMA strategija}
    \label{fig:ltcbusd_sma_trades}
  \end{subfigure}
  \caption{LTCBUSD prekyba}
  \label{fig:ltcbusd_trades}
\end{figure}

Gauti rezultatai robotui prekiaujant pritaikius anksčiau minėtas strategijas. Kaip matome robotas dažnai bando atlikti pakartotinus užsakymus dėl nustatyto "LIMIT" užsakymo tipo ir galiausiai ne visada užsakymas pavyksta. Pastebima, kad 
grįžimo prie vidurkio strategija, atlieka žymiai mažiau bandymų prekiauti lyginant su tendencijos sekimu. Bendrai paėmus
visos su visomis poros buvo atlikta nors vienas pirkimas ir pardavimas. Taip pat pastebima, jog šios kriptovaliutos turi 
labai panašią grafiko tendenciją 

\begin{table}[H]
  \centering
  \begin{tabularx}{\linewidth}{|X|X|X|X|}
    \hline
    Strategija             & Krepšelio pokytis \\
    \hline
    Tendencijos sekimas    & +5.54 BUSD        \\
    \hline
    Grįžimas prie vidurkio & -0.32 BUSD        \\
    \hline
  \end{tabularx}
  \caption{Prekybos rezultatai}
  \label{table:preykos_rezultatai}
\end{table}

Tendencijos sekimo strategija atneše šiek tiek pelno po nakties prekybos. Tai galimai įtakoja didesnis atliktų prekybos kiekis, nes bandoma tiesiog pasipelnyti iš tendencijos į kurią kryptį keliaujama. Grįžimo prie vidurkio strategija atliko 
mažai užsakymų ir atnešė labai maža nuostolį. Ši strategija galbūt nėra pats geriausias pasirinkimas trumpalaikiui prekiavimui
tokioje aplinkoje.

% Išvadose ir pasiūlymuose, nekartojant atskirų dalių apibendrinimų,
% suformuluojamos svarbiausios darbo išvados, rekomendacijos bei pasiūlymai.
\section{Išvados ir rezultatai}

Šiame darbe buvo siekiama sukurti automatizuota kriptovaliutų robotą, kuris implementuoja strategijas taikančias autoregresines modelių analizes.
Tikslui pasiekti buvo įvykdyti šie uždaviniai: susipažinta su autoregresiniais modeliais, jų savybėmis; susipažinta su darbine aplinka ir sukurtas
robotas naudojantis šiuos įrankius; susipažinta su strategijomis ir jos pritaikytos robotui. 

Projekto metu sukurtas automatizuotas robotas

Rezultatai
\begin{itemize}
  \item atlikta autoregresinių modelių analizė,
  \item sukurtas robotas gebantis prekiauti testiniame tinkle
\end{itemize}

Išvados
\begin{itemize}
  \item parinkta naudoti ARIMA modelį prognozėmis,
  \item robotas daugiau prekybos atlieka taikant tendencijos strategija
\end{itemize}

Neišvengiama, jog tokiame trumpame darbe būtų aptartos visos įmanomos sritys ir atvejai, taigi tolimesnei tyrimo eigai pasiūlymas nagrinėti kitus modelius
ir duomenų rinkinius, kad būtų galima palyginti prognozavimo būdus aptartais šiame darbe. Taip pat galima analizuoti alternatyvias strategijas kurias galima
pritaikyti robotui ir jas palyginti. 

\sectionnonum{Sąvokų apibrėžimai}

\textbf{API} - Aplikacijų programavimo sąsaja (angl. Application programming interface), tai sistemos suteikiama sąsaja, kuria galima naudotis norint pasiekti tos sistemos
funckionalumą ar apsikeisti duomenimis.

\textbf{Autoregresinis modelis} - Statistinis modelis yra autoregresinis, jei jis numato būsimas reikšmes pagal praeities reikšmes. Pavyzdžiui, autoregresinis modelis gali
siekti numatyti būsimas akcijų kainas, remiantis ankstesniais rezultatais.

\textbf{Euristinis algoritmas} - euristiniai algoritmai yra tokios intelektualios optimizavimo uždavinių sprendimo priemonės, kuriomis siekiama rasti aukštos
kokybės (bet nebūtinai optimalius) sprendinius per priimtiną laiką. Algoritmas negarantuoja, kad rastas sprendimas bus optimalus. \cite{misevivcius2009euristiniku}

\textbf{FOK} - "Fill or Kill" - limitinis sandorio tipas kai už norimą kainą, atlikti sandorį tik jei jis yra pilnai įvykdomas.

\textbf{GTC} - "Good til cancelled" - limitinis sandorio tipas kai už norimą kainą, sandoris yra paliekamas rinkoje iki tol kol pilnai įvykdomas arba rankiniu būdu atšaukiamas.

\textbf{IOC} - "Immediate or cancel" - limitinis sandorio tipas kai už norimą kainą, sandoris yra atliekamas tik tada jei nors dalis sandorio yra iškarto įvykdoma.

\textbf{Kriptovaliuta} - Kriptovaliuta yra skaitmeninė arba virtuali valiuta, kuri yra apsaugota kriptografija, todėl beveik neįmanoma jos padirbti ar išleisti dvigubai.

\textbf{Kriptovaliutų pora} - Kriptovaliutų pora rinkoje yra naudojama prekiaujant. Kriptovaliutos yra susietos poromis, norint nusipirkt BTC valiutos pirmiausia reikia surasti 
galimus keitimo variantus, jei egzistuoja pora BTC/BUSD, galima nusipirkti BTC kriptovaliutos uz turimas BUSD valiutas. Dažnu atveju rinkoje pasidėjus ("FIAT") valiuta
prekybos rinką ją konvertuoją i panašią valiuta kaip BUSD, USDT ar BNB.
prekybos rinką ją konvertuoją i panašių token valiuta kaip BUSD(us -regulated stablecoin), USDT (usd tether) ar BNB (binance coin)

\textbf{LIMIT užsakymas} - Prekybos rinkoje bandomas atlikti užsakymas su vartotojo nustatyta kaina.

\textbf{MARKET užsakymas} - Prekybos rinkoje atliekamas užsakymas automatiškai gaunant geriausia siūloma kainą rinkoje tuo metu.

\textbf{MSE} - Vidutinė kvadratinė paklaida, angl. (Mean squared error)

\textbf{MAPE} - Vidutinė  bsoliučioji paklaida išreikšta procentais, angl. (Mean absolute percentage error)

\textbf{Wrapper API} - sluoksnis, esantis ant esamo API, kuris palengvina naudojimą. Tai suteikia supaprastintą sąsają prieigai prie pagrindinio API, padarydama ją patogesnę vartotojui. „Python“ Wrapper API pavyzdys yra „python-binance“, kuris apgaubia „Binance“ API, kad būtų galima patogiai bendrauti su „Binance“ platforma.

\printbibliography[heading=bibintoc] % Aprašomi literatūros šaltiniai

\appendix  % Priedai
% Prieduose gali būti pateikiama pagalbinė, ypač darbo autoriaus savarankiškai
% parengta, medžiaga. Savarankiški priedai gali būti pateikiami kompiuterio
% diskelyje ar kompaktiniame diske. Priedai taip pat vadinami ir numeruojami.
% Tekstas su priedais siejamas nuorodomis (pvz.: \ref{img:mlp}).

\end{document}
